<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GLB Viewer — simple</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#111}
    canvas{display:block;width:100%;height:100%}
    #msg{position:fixed;left:12px;top:12px;right:12px;padding:10px;border-radius:8px;
         background:#2b2b2b;color:#eee;font:13px/1.45 system-ui,Arial}
  </style>
</head>
<body>
<div id="msg">Загружается…</div>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';

  const banner = document.getElementById('msg');
  const set = (t, ok=false)=>{ banner.textContent=t; banner.style.background = ok ? '#1f2b1f' : '#2b2b2b'; banner.style.color = ok ? '#d6ffd6' : '#eee'; }

  // Сцена
  const scene = new THREE.Scene(); scene.background = new THREE.Color(0x202225);
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 5000);
  const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.toneMapping = THREE.ACESFilmicToneMapping;
  document.body.appendChild(renderer.domElement);

  // Свет
  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3,5,2); scene.add(dir);

  camera.position.set(0, 1, 3);

  // Загрузка модели (путь — файл рядом с index.html)
  const MODEL_URL = new URL('./PScolor_3D.glb', location.href).toString();
  let root = null;
  new GLTFLoader().load(MODEL_URL, (gltf) => {
    root = gltf.scene;
    scene.add(root);
    fit(camera, root);
    set('Готово', true);
    setTimeout(()=>banner.remove(), 1000);
  }, (e) => {
    if (e.total) set('Загрузка ' + (e.loaded/e.total*100).toFixed(0) + '%');
  }, (err) => {
    set('Ошибка загрузки: ' + (err?.message || err));
    console.error(err);
  });

  // Кадрирование камеры под модель
  function fit(cam, obj){
    const box = new THREE.Box3().setFromObject(obj);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    const max = Math.max(size.x, size.y, size.z) || 1;
    const dist = max / (2 * Math.tan(THREE.MathUtils.degToRad(cam.fov) / 2));
    cam.near = dist/100; cam.far = dist*100; cam.updateProjectionMatrix();
    cam.position.copy(center).add(new THREE.Vector3(dist, dist*0.3, dist));
    // Помещаем модель в центр
    const pivot = new THREE.Group(); pivot.position.copy(center);
    obj.position.sub(center); // смещаем модель так, чтобы центр оказался в (0,0,0) pivot'а
    pivot.add(obj); scene.add(pivot);
    root = pivot;
  }

  // Рендер-цикл (авто-поворот вместо контролов)
  function loop(){
    requestAnimationFrame(loop);
    if (root) root.rotation.y += 0.004;
    renderer.render(scene, camera);
  }
  loop();

  // Ресайз
  addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
</script>
</body>
</html>
