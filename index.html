<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PScolor_3D.glb — Three.js Viewer</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#111}
    #progress{position:fixed;left:12px;bottom:12px;font:12px/1.2 system-ui,Arial;color:#ddd;opacity:.9}
    #error{position:fixed;left:12px;top:12px;right:12px;padding:12px;border-radius:8px;
           background:#2b1b1b;color:#ffdada;font:13px/1.4 system-ui,Arial;display:none;white-space:pre-wrap}
    canvas{display:block;width:100%;height:100%}
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="progress">Загрузка…</div>
<div id="error"></div>
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const errBox = document.getElementById('error');
function showError(msg){
  errBox.style.display = 'block';
  errBox.textContent = 'Ошибка: ' + msg;
  console.error(msg);
}
window.addEventListener('error', e => showError(e.message));
window.addEventListener('unhandledrejection', e => showError(String(e.reason?.message || e.reason || e)));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 2000);
camera.position.set(0, 1, 3);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1;
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(3, 5, 2);
scene.add(dir);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;

const progress = document.getElementById('progress');
const loader = new GLTFLoader();
loader.load('./PScolor_3D.glb', (gltf) => {
  const root = gltf.scene;
  scene.add(root);
  fitCameraToObject(camera, root, controls);
  progress.textContent = 'Готово';
  setTimeout(()=>progress.remove(), 800);
}, (e) => {
  if (e.total) progress.textContent = 'Загрузка ' + (e.loaded/e.total*100).toFixed(0) + '%';
}, (err) => {
  showError('Не удалось загрузить PScolor_3D.glb\n' + (err.message || err));
});

function fitCameraToObject(cam, object, controls){
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxSize = Math.max(size.x, size.y, size.z) || 1;
  const fitHeightDistance = maxSize / (2 * Math.tan(THREE.MathUtils.degToRad(cam.fov) / 2));
  const fitWidthDistance  = fitHeightDistance / cam.aspect;
  const distance = 1.2 * Math.max(fitHeightDistance, fitWidthDistance);
  cam.near = distance / 100;
  cam.far  = distance * 100;
  cam.updateProjectionMatrix();
  cam.position.copy(center).add(new THREE.Vector3(distance, distance*0.3, distance));
  controls.target.copy(center);
  controls.update();
}

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
